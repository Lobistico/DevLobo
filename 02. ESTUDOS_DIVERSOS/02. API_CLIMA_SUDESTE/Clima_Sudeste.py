# -*- coding: utf-8 -*-
"""Estudo_xml_etree.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15Q3Gd5nprg3rzGHoX_veSbe2JeeeEhsO

## IMPORTANDO
"""

import xml.etree.ElementTree as ET
import requests
import pandas as pd
import matplotlib.pyplot as plt
import sqlite3

"""## TRATAMENTO INICIAL
A primeira etapa foi importar o arquivo xml utilizando xml.etree e o requests

"""

# IMPORTA ARQUIVO XML
url = "http://servicos.cptec.inpe.br/XML/capitais/condicoesAtuais.xml"
header = { 'Accept': 'application/xml' }
r = requests.get(url, headers=header)

tree =  ET.ElementTree(ET.fromstring(r.content))    
root = tree.getroot()

# LISTA DAS ESTAÇÕES DOS ESTADOS
codigos = ['SBRJ','SBSP','SBVT', 'SBCF']
cidades = ['Rio de Janeiro', 'São Paulo', 'Vitória', 'Belo Horizonte']
dc_cid_cod ={}

# SALVA AS ESTAÇÕES
for k,j in zip(codigos, cidades):
  dc_cid_cod[k] = j

"""## SALVANDO
Criando o banco de dados, são salvas as informações relaciondas com:

1.   Código da estação;
2.   Atualização
3.   Temperatura
4.   Umidade do Ar
"""

conexao = sqlite3.connect('basededados.db')
cursor = conexao.cursor()

cursor.execute('CREATE TABLE IF NOT EXISTS previsao_tempo ('
                'id INTEGER PRIMARY KEY AUTOINCREMENT,'
                'codigo TEXT,'
                'atualizacao TEXT,'
                'temperatura INTEGER,'
                'ar_umido INTEGER,'
                'a_tempo TEXT'
                ')')
teste ={} # Salva um dicionário teste com temperatura e estação.
predominio=[] # Salva o predominio do momento.

for i  in range(0, 26):
  if root[i][0].text in codigos:
    teste[root[i][0].text] = root[i][3].text
    predominio.append(root[i][5].text)    
    cursor.execute('INSERT INTO previsao_tempo (codigo, atualizacao, temperatura, ar_umido, a_tempo) VALUES (?, ?, ?, ?, ?)', (dc_cid_cod[root[i][0].text],root[i][1].text,root[i][3].text,root[i][6].text,root[i][5].text))
    # print(f' Na estação {dc_cid_cod[root[i][0].text]} está fazendo {root[i][3].text} graus')  -- > É um teste para verificar se está funcionando o código
conexao.commit()
# PARA VER COMO ESTÁ SENDO SALVO 
# cursor.execute('SELECT * FROM previsao_tempo')
# for linha in cursor.fetchall():
#     print(linha)
cursor.close()
conexao.close()

# CORRIGE ACENTO DO PREDOMINIO
for x in range(0, len(predominio)):  
    predominio[x] = predominio[x].replace('Ã\xad', 'í')

"""## REPRESENTAÇÃO
Primeiro: apresentação de tabela com a temperatura e o predomínio do clima,
Segundo: apresentação de tabela para indicar a temperatura.
"""

# CRIA O TABELA COM A TEMPERATURA 
estacao = list(teste)
temperatura = list(teste.values())
d = {'Estacao': estacao, 'Temperatura': temperatura, 'Predominio': predominio}
df = pd.DataFrame(data=d)

df['Temperatura'] = pd.to_numeric(df['Temperatura']) # Converte para Integer
df

# CRIA GRAFICO COM A TEMPERATURA ATUAL
df.groupby(df['Estacao'])['Temperatura'].sum().plot.barh(title  = 'Temperatura', color ='red', figsize=(20,5));

"""## RECUPERAÇÃO
Transforma os banco de dados em um arquivo CSV
Recupera o arquivo CSV para tratamento de dados
"""

#RECUPERAÇÃO DE DADOS - SALVA EM CSV
conect = sqlite3.connect('/content/basededados.db')

dados_recuperados = pd.read_sql_query("SELECT * FROM previsao_tempo", conect)
dados_recuperados.to_csv('dados.csv',index=False)

# IMPORTA O CSV 
x = '/content/dados.csv'

dff = pd.read_csv(x, encoding= 'unicode_escape', error_bad_lines=False,sep=',')

dff['atualizacao'] = pd.to_datetime(dff['atualizacao']) # TRANSFORMA EM DATA
dff



""" ANOTAÇÕES DE ESTUDO"""


# TESTE DE VERIFICAÇÃO UM
# teste ={}
# for i  in range(0, 26):
#   if root[i][0].text in códigos:
#     teste[root[i][0].text] = root[i][3].text
#     print(f' Na estação {root[i][0].text} está fazendo {root[i][3].text} graus')  


# print(root[0][0].text) 

#VISUALIZA_RAIZ
#print(root.attrib)

# #ESTUDO_VISUALIZAR_METAR ___TESTE DE INTEGRAÇÃO
# for child in root:
#   for codigo in child:
#     #for valor in codigo:
#       print(codigo.text)
#     #print(codigo.tag, codigo.attrib)
#     # print(child.tag, child.attrib)


# # VERIFICAÇÃO LÓGICA --- TESTE DE VERIFICAÇÃO
# for child in root.findall("metar"):
#     for title in child.findall("codigo"):
#       if title.text in códigos:        
#         print(title.text)


# print(root[0][0].text)  acessa o primeiro item do xml